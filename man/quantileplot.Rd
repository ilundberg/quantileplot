% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantileplot.R
\name{quantileplot}
\alias{quantileplot}
\title{Create a Smooth Quantile Plot}
\usage{
quantileplot(
  formula,
  data,
  weights = NULL,
  xlab = NULL,
  ylab = NULL,
  x_break_labeller = NULL,
  y_break_labeller = NULL,
  slice_n = 7,
  quantiles = c(0.1, 0.25, 0.5, 0.75, 0.9),
  quantile_notation = "label",
  truncation_notation = "label",
  uncertainty_draws = NULL,
  show_ci = FALSE,
  ci = 0.95,
  second_formula = NULL,
  x_range = NULL,
  y_range = NULL,
  x_bw = NULL,
  y_bw = NULL,
  inverse_transformation = NULL,
  granularity = 512,
  previous_fit = NULL,
  ...
)
}
\arguments{
\item{formula}{A bivariate model formula (e.g. \code{y ~ x})}

\item{data}{Data frame containing the variables in \code{formula}. If \code{weights} are specified, they must be a column of \code{data}.}

\item{weights}{String name for sampling weights, which are a column of \code{data}. If not given, a simple random sample is assumed.}

\item{xlab}{String x-axis title}

\item{ylab}{String y-axis title}

\item{x_break_labeller}{Function to convert labels on x-axis breaks into an alternative format.}

\item{y_break_labeller}{Function to convert labels on y-axis breaks into an alternative format.}

\item{slice_n}{Integer number of vertical slices (conditional densities of y given x) to be plotted. Default is 7.}

\item{quantiles}{Numeric vector containing quantiles to be estimated. Values should be between 0 and 1.}

\item{quantile_notation}{String, either \code{label} or \code{legend}. If \code{label} (the default), then quantile curves are annotated in the plot. If \code{legend}, then quantile curves are denoted by colors with a legend.}

\item{truncation_notation}{String, one of \code{label}, \code{label_no_pct}, or \code{none}. If \code{x_range} or \code{y_range} is narrower than the range of the data, this argument specifies how to note that truncation on the visualization. If \code{label}, then truncation is labeled including the percent of data truncated. If \code{label_no_pct}, then truncation is labeled but the percent truncated is omitted. If \code{none}, then truncation is not labeled on the plot.}

\item{uncertainty_draws}{Numeric. If non-null, the number of simulated posterior draws to estimate for each smooth quantile curve. When used with the \code{plot} function, these appear in panels below the main plot.}

\item{show_ci}{Logical, defaults to \code{FALSE}. Whether to show credible intervals for the estimated smooth quantile curves.}

\item{ci}{Numeric probability value for credible intervals; default to 0.95 to produce 95 percent credible intervals. Only relevant if \code{show_ci = TRUE}.}

\item{second_formula}{Model formula to allow the learning rate to change as a function of the predictor. This is passed to \code{mqgam} as the second element in the \code{form} argument. Defaults to the same specification as \code{formula} but without the outcome variable.}

\item{x_range}{Numeric vector of length 2 containing the range of horizontal values to be plotted. Defaults to the range of the predictor variable in \code{data}. You may want to specify a narrower range if the predictor is extremely skewed.}

\item{y_range}{Numeric vector of length 2 containing the range of vertical values to be plotted. Defaults to the range of the outcome variable in \code{data}. You may want to specify a narrower range if the outcome is extremely skewed.}

\item{x_bw}{Numeric bandwidth for density estimation in the \code{x} dimension. The standard deviation of a Gaussian kernel. If \code{NULL}, this is set by the defaults in \code{stats::density()}.}

\item{y_bw}{Numeric bandwidth for density estimation in the \code{y} dimension. The standard deviation of a Gaussian kernel. If \code{NULL}, this is set by the defaults in \code{stats::density()}.}

\item{inverse_transformation}{A function of an argument named x. This is only used if the argument passed to formula involves a transformation of the outcome variable (e.g. log(y + 1)), then you need to provide the inverse of that transformation so that the returned plot can be visualized on the original scale of the outcome variable. For common transformations (e.g. log(y)), this argument can be determined automatically. To produce a plot with the predictor or outcome visualized on a transformed scale, you should not place the transformation within the model formula but instead should create your transformed variable in the data before calling the quantileplot function.}

\item{granularity}{Integer number of points at which to evaluate each density. Defaults to 512, as in \code{stats::density()}. Higher values yield more granular density estimates.}

\item{previous_fit}{The result of a previous call to \code{quantileplot}. If provided, then the \code{mqgam} fit for the quantile curves will not be re-estimated, which can be useful for iteratively deciding about other arguments in settings that are computationally demanding. This argument must be paired with other arguments that match the previous call (e.g. \code{data}, \code{formula}).}

\item{...}{Other arguments passed to \code{mqgam} for fitting of smooth quantile curves.}
}
\value{
An object of S3 class \code{quantileplot}, which supports \code{summary()}, \code{print()}, and \code{plot()} functions. The returned object has several elements.
\itemize{
\item \code{plot} is a \code{ggplot2} object. This contains the most basic plot. The user can customize this output by passing additional layers to \code{quantileplot.out$plot} as they would for any \code{ggplot2} object.
\item \code{sim_curve_plots} is a list object of \code{ggplot2} objects, one for each quantile curve, which shows the point estimate for the curve in black and a series of simulated posterior samples in gray.
\item \code{densities} is a list of length four.
\itemize{
\item \code{marginal} and \code{conditional} are data frames containing the estimated marginal and conditional densities.
\item \code{x_bw} and \code{y_bw} are the bandwidths used for Gaussian kernel density estimation.
}
\item \code{curves} is a data frame containing the estimated quantile curves.
\item \code{mqgam.out} is the output from the call to the \code{mqgam} function in the \code{qgam} package, which is used to estimate the quantile curves.
\item \code{x_range} and \code{y_range} are the horizontal and vertical ranges of the plot.
\item \code{slice_x_values} are the predictor values at which vertical conditional densities are estimated.
\item \code{call} is the user's call that produced these results.
\item \code{arguments} is a list of all the arguments to the function, including those specified by the user and those specified by defaults.
}
}
\description{
Creates a bivariate, smooth quantile plot. This is the central function of the \code{quantileplot} package. This plot visualizes estimates of the marginal density of the predictor, the conditional density of the outcome at selected values of the predictor, and smooth curves showing quantiles of the outcome as smooth functions of the predictor. This package is described in greater depth by Lee et al. (2021), which is a generalization of Lundberg and Stewart (2020). The statistical core of the package relies on the methods of Fasiolo et al. (2020).
}
\examples{
x <- rbeta(1000,1,2)
y <- log(1 + 9 * x) * rbeta(1000, 1, 2)
data <- data.frame(x = x, y = y)
quantileplot(y ~ s(x), data)
}
\references{
Lee, Robin C., Ian Lundberg, and Brandon M. Stewart. 2021. "Smooth quantile visualizations enhance understanding of bivariate population distributions." Working paper.

Lundberg, Ian, and Brandon M. Stewart. 2020. "Comment: Summarizing income mobility with multiple smooth quantiles instead of parameterized means." Sociological Methodology 50(1):96-111.

Fasiolo, Matteo, Simon N. Wood, Margaux Zaffran, RaphaÃ«l Nedellec, and Yannig Goude. 2020. "Fast calibrated additive quantile regression." Journal of the American Statistical Association.
}
